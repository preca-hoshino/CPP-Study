2019.12.14 星期六
## 动态规划
[想获得更加的阅读体验？](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdiin)

动态规划是运筹学的一个分支,是求解决策过程最优化的数学方法.

20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划.

-----------
现在有一个问题

假设有5个金矿,10个人.挖第i个金矿时消耗$a[i]$个人,得到$b[i]$个价值.请问最多能得到多少价值?

假设用$f(n)(m)$代表挖到第n个矿时剩下m个人时可以得到的价值,可以得到公式:

$f(n)(m)=max(f(n-1)(m),f(n-1)(m-a[n])+b[n])$

代码1如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10]={0,0,0,0,0,1000},b[10]={0,200,300,350,400,500},dp[11][11]={0};
int main()
{
	for(int i=1;i<=5;i++)
	{
		for(int j=0;j<=10;j++)
		{
			if(j>=a[i])
			{
				dp[i][j]=max(dp[i-1][j],dp[i-1][j-a[i]]+b[i]);
			}
			else
			{
				dp[i][j]=dp[i-1][j];
			}
		}
	}
	printf("%d",dp[5][10]);
}
```
我们仔细研究一下我们的公式,就会发现$f(n)(m)$只和$f(n-1)(m)$有关系,所以我们可以把dp数组压缩成2行.

代码2如下:
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10]={0,0,0,0,0,1000},b={0,200,300,350,400,500};
int dp[100]={0};//压缩成2行
int main()
{
	for(int i=1;i<=5;i++)
	{
		for(int j=0;j<=10;j++)
		{
			if(j>=a[i])
			{
				dp[1&i][j]=max(dp[1-(1&i)][j],dp[1-(1&i)][j-a[i]]+b[i]);//1&i控制行数
			}
			else
			{
				dp[1&i][j]=dp[1-(1&i)][j];
			}
		}
	}
	printf("%d",dp[5&1][10]);
}
```
我们还可以压缩成1行,当我们计算$f(n)(m)$,调用$f(n-1)(m)$时,$f(n-1)(m)$仍是上次计算的值,因此直接调用.压缩成1行时注意for(j)循环要倒着遍历.

代码3如下:
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10]={0,0,0,0,0,1000},b[10]={0,200,300,350,400,500};
int dp[11]={0};
int main()
{
	for(int i=1;i<=5;i++)
	{
		for(int j=10;j>=a[i];j--)
		{
			dp[j]=max(dp[j],dp[j-a[i]]+b[i]);
		}
	}
	printf("%d",dp[10]);
}
```