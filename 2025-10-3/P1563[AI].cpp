// AGENT CODE
// P1563 - [NOIP 2016 提高组] 玩具谜题
// GitHub Copilot - 2025-10-14 00:00:00

/*
 * 题目要求：模拟环形队列中根据朝向和指令移动
 * 
 * 核心规则：
 * - 玩具小人围成圈（环形数组）
 * - 朝向决定左右的实际方向
 * - 朝内(0)：左=顺时针(+)，右=逆时针(-)
 * - 朝外(1)：左=逆时针(-)，右=顺时针(+)
 * 
 * 解题思路：
 * 1. 存储每个玩具小人的朝向和职业
 * 2. 从第1个玩具小人（索引0）开始
 * 3. 对每条指令，根据当前朝向和指令方向计算实际移动
 * 4. 使用取模运算处理环形移动
 * 5. 输出最终位置的玩具小人职业
 * 
 * 移动规则总结：
 * - 朝向0(朝内) + 方向0(左) = 顺时针 → pos + s
 * - 朝向0(朝内) + 方向1(右) = 逆时针 → pos - s
 * - 朝向1(朝外) + 方向0(左) = 逆时针 → pos - s
 * - 朝向1(朝外) + 方向1(右) = 顺时针 → pos + s
 * 
 * 时间复杂度：O(n + m)
 * 空间复杂度：O(n)
 */

#include<bits/stdc++.h>
using namespace std;

int main()
{
    int n = 0, m = 0;
    cin >> n >> m;
    
    // 存储每个玩具小人的朝向和职业
    vector<int> direction(n);      // 0-朝内，1-朝外
    vector<string> profession(n);  // 职业名称
    
    // 读取玩具小人信息（逆时针顺序）
    for(int i = 0; i < n; i++)
    {
        cin >> direction[i] >> profession[i];
    }
    
    // 当前位置，从第1个玩具小人开始（索引0）
    int pos = 0;
    
    // 执行m条指令
    for(int i = 0; i < m; i++)
    {
        int a = 0, s = 0;
        cin >> a >> s;
        
        // 根据当前玩具小人的朝向和指令方向，计算实际移动
        // direction[pos]: 当前玩具小人的朝向
        // a: 指令方向（0-左，1-右）
        
        // 判断实际移动方向（顺时针或逆时针）
        // 输入是逆时针顺序，所以：
        // - 顺时针 = 索引减小
        // - 逆时针 = 索引增大
        // 
        // 朝向和指令相同时：顺时针（索引减小）
        // 朝向和指令不同时：逆时针（索引增大）
        if(direction[pos] == a)
        {
            // 朝内左 或 朝外右 → 顺时针 → 索引减小
            pos = (pos - s + n) % n;  // 加n防止负数
        }
        else
        {
            // 朝内右 或 朝外左 → 逆时针 → 索引增大
            pos = (pos + s) % n;
        }
    }
    
    // 输出最终位置的玩具小人职业
    cout << profession[pos];
    return 0;
}

/*
 * 示例分析1：
 * 输入: n=7, m=3
 * 玩具小人（索引, 朝向, 职业）:
 * 0: 朝内(0), singer
 * 1: 朝内(0), reader
 * 2: 朝内(0), mengbier
 * 3: 朝外(1), thinker
 * 4: 朝外(1), archer
 * 5: 朝内(0), writer
 * 6: 朝外(1), mogician
 * 
 * 执行过程：
 * 初始: pos=0 (singer, 朝内)
 * 
 * 指令1: a=0(左), s=3
 * - 当前朝内(0)，左(0) → 方向相同 → 顺时针
 * - pos = (0 + 3) % 7 = 3 (thinker, 朝外)
 * 
 * 指令2: a=1(右), s=1
 * - 当前朝外(1)，右(1) → 方向相同 → 顺时针
 * - pos = (3 + 1) % 7 = 4 (archer, 朝外)
 * 
 * 指令3: a=0(左), s=2
 * - 当前朝外(1)，左(0) → 方向不同 → 逆时针
 * - pos = (4 - 2 + 7) % 7 = 5 (writer, 朝内)
 * 
 * 最终输出: writer
 * 
 * 方向规律说明：
 * - direction[pos] == a 时，实际是顺时针移动
 *   因为：朝内0+左0=顺时针，朝外1+右1=顺时针
 * - direction[pos] != a 时，实际是逆时针移动
 *   因为：朝内0+右1=逆时针，朝外1+左0=逆时针
 */
