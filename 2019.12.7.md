2019.12.7 星期六
## gcd
[想获得更加的阅读体验？](https://baike.baidu.com/item/GCD/24166657#viewPageContent)

今天我们学习了gcd(最大公约数)算法,具体实现如下:

若$f(x,y)$表示x,y的最小公倍数,就有

$k$=$x$%$y$

$f(x,y)$=$f(y,k)$,$(y>0)$

$f(x,y)$=$x$,$(y=0)$

定义清楚了,写代码就容易了

```cpp
#include<bits/stdc++.h>
using namespace std;
int gcd1(int x,int y)//递归法 
{
	if(!y)
		return x;
	else
		return gcd1(y,x%y);
}
int gcd2(int a,int b)//循环法 
{
	int t;
	if(a<b)
	{
		swap(a,b);//交换a,b的值
	}
	while(b)
	{
		t=b;
		b=a%b;
		a=t;
	}
	return a;
}
int gcd3(int a,int b)
{
	int t;
	while(b)
	{
		if(a<b)
		{
			swap(a,b);
		}
		t=a-b;
		a=b;
		b=t;
	}
	return a;
}
int main()
{
	int n,m,t;
	scanf("%d%d",&n,&m); 
	printf("%d\n%d\n%d",gcd1(n,m),gcd2(n,m),gcd3(n,m));
	return 0;
} 

```
## 高精度
[想获得更加的阅读体验？](https://baike.baidu.com/item/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97/2671214)

高精度运算，是指参与运算的数(加数，减数，因子……）范围大大超出了标准数据类型（整型，实型）能表示的范围的运算。例如，求两个20000位的数的和。

这里给出的为高精度除法,有兴趣的可以看另外几种算法

代码如下:

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[10000];
int ans[10000]={0};
int n;
int main()
{
	cin>>a>>n;
	int len=strlen(a);
	for(int i=0;i<len;i++)
	{
		ans[i]=a[i]-'0';
	}//读入,由于是高到低运算,所以不用倒着存
	int l=0;
	int t=0;
	for(int i=0;i<len;i++)
	{
		l+=ans[i];
		if((l/n)==0)
		{
			if(t)
				printf("0");
			l*=10;
		}
		else
		{
			printf("%d",l/n);
			l=(l%n)*10;
			t=1;
		}
	}//计算
	printf(" mod %d",l/10);//输出余数
	return 0;
}
```
## 3.快速幂

[想获得更加的阅读体验？](https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E5%B9%82/5500243?fr=aladdin)

我们经常要进行乘方运算，按照原本的循环算法，如果算$2^n$,那么时间复杂度为$o(n)$。

于是快速幂来了，它能降低时间复杂度，具体来看一看算法实现:

如果要算2的17次方，那么17按照2进制可以分解为

$(17)10=(10001)2$

于是2的17次方可以分解为

$2^4$*$2^0$

分解之后大大地降低了时间复杂度，在算更大的乘方的时候，这一优势更能体现
代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
int x,y;
int s(int x,int y)
{
    int ans=1,b=x;
    while(y)
    {
        if(y&1)
        {
            ans*=b;
        }
        y>>=1;
        b*=b;
    }
    return ans;
}
int main()
{
    scanf("%d%d%d",&x,&y,&k);
    printf("%d^%d mod %d=%d",x,y,s(x,y));
    return 0;
}
```
